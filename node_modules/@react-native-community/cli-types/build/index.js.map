{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAMA","sourcesContent":["import {\n  IOSProjectConfig,\n  IOSProjectParams,\n  IOSDependencyConfig,\n  IOSDependencyParams,\n} from './ios';\nimport {\n  AndroidProjectConfig,\n  AndroidProjectParams,\n  AndroidDependencyConfig,\n  AndroidDependencyParams,\n} from './android';\n\nexport type InquirerPrompt = any;\n\nexport type CommandFunction<Args = Object> = (\n  argv: Array<string>,\n  ctx: Config,\n  args: Args,\n) => Promise<void> | void;\n\nexport type OptionValue = string | boolean | number;\n\nexport type CommandOption<T = (ctx: Config) => OptionValue> = {\n  name: string;\n  description?: string;\n  parse?: (val: string) => any;\n  default?: OptionValue | T;\n};\n\nexport type DetachedCommandFunction<Args = Object> = (\n  argv: string[],\n  args: Args,\n) => Promise<void> | void;\n\nexport type Command<IsDetached extends boolean = false> = {\n  name: string;\n  description?: string;\n  detached?: IsDetached;\n  examples?: Array<{\n    desc: string;\n    cmd: string;\n  }>;\n  pkg?: {\n    name: string;\n    version: string;\n  };\n  func: IsDetached extends true\n    ? DetachedCommandFunction<Object>\n    : CommandFunction<Object>;\n  options?: Array<\n    CommandOption<\n      IsDetached extends true ? () => OptionValue : (ctx: Config) => OptionValue\n    >\n  >;\n};\n\nexport type DetachedCommand = Command<true>;\n\ninterface PlatformConfig<\n  ProjectConfig,\n  ProjectParams,\n  DependencyConfig,\n  DependencyParams\n> {\n  projectConfig: (\n    projectRoot: string,\n    projectParams: ProjectParams | void,\n  ) => ProjectConfig | void;\n  dependencyConfig: (\n    dependency: string,\n    params: DependencyParams,\n  ) => DependencyConfig | void;\n  linkConfig: () => {\n    isInstalled: (\n      projectConfig: ProjectConfig,\n      packageName: string,\n      dependencyConfig: DependencyConfig,\n    ) => boolean;\n    register: (\n      name: string,\n      dependencyConfig: DependencyConfig,\n      params: Object,\n      projectConfig: ProjectConfig,\n    ) => void;\n    unregister: (\n      name: string,\n      dependencyConfig: DependencyConfig,\n      projectConfig: ProjectConfig,\n      otherDependencies: Array<DependencyConfig>,\n    ) => void;\n    copyAssets: (assets: string[], projectConfig: ProjectConfig) => void;\n    unlinkAssets: (assets: string[], projectConfig: ProjectConfig) => void;\n  };\n}\n\nexport interface Dependency {\n  name: string;\n  root: string;\n  platforms: {\n    android?: AndroidDependencyConfig | null;\n    ios?: IOSDependencyConfig | null;\n    [key: string]: any;\n  };\n  assets: string[];\n  hooks: {\n    prelink?: string;\n    postlink?: string;\n    preunlink?: string;\n    postunlink?: string;\n  };\n  params: InquirerPrompt[];\n}\n\nexport type ProjectConfig = {\n  android?: AndroidProjectConfig;\n  ios?: IOSProjectConfig;\n  [key: string]: any;\n};\n\n/**\n * @property root - Root where the configuration has been resolved from\n * @property reactNativePath - Path to React Native source\n * @property project - Object that contains configuration for a project (null, when platform not available)\n * @property assets - An array of assets as defined by the user\n * @property dependencies - Map of the dependencies that are present in the project\n * @property platforms - Map of available platforms (build-ins and dynamically loaded)\n * @property commands - An array of commands that are present in 3rd party packages\n */\nexport type Config = {\n  root: string;\n  reactNativePath: string;\n  project: ProjectConfig;\n  assets: string[];\n  dependencies: {[key: string]: Dependency};\n  platforms: {\n    android: PlatformConfig<\n      AndroidProjectConfig,\n      AndroidProjectParams,\n      AndroidDependencyConfig,\n      AndroidDependencyParams\n    >;\n    ios: PlatformConfig<\n      IOSProjectConfig,\n      IOSProjectParams,\n      IOSDependencyConfig,\n      IOSDependencyParams\n    >;\n    [name: string]: PlatformConfig<any, any, any, any>;\n  };\n  commands: Command[];\n};\n\n/**\n * Shares some structure with Config, except that root is calculated and can't\n * be defined\n */\n\nexport type UserConfig = Omit<Config, 'root'> & {\n  reactNativePath: string | void;\n  // Additional project settings\n  project: {\n    android?: AndroidProjectParams;\n    ios?: IOSProjectParams;\n    [key: string]: any;\n  };\n};\n\nexport type UserDependencyConfig = {\n  // Additional dependency settings\n  dependency: Omit<Dependency, 'name' | 'root'>;\n  // An array of commands that ship with the dependency\n  commands: Command[];\n  // An array of extra platforms to load\n  platforms: Config['platforms'];\n};\n\nexport {\n  IOSProjectConfig,\n  IOSProjectParams,\n  IOSDependencyConfig,\n  IOSDependencyParams,\n};\n\nexport {\n  AndroidProjectConfig,\n  AndroidProjectParams,\n  AndroidDependencyConfig,\n  AndroidDependencyParams,\n};\n"]}